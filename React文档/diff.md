[toc]

diff 算法

# 1. React 更新面临的问题
React 组件更新的本质是, 根据React 代码重新获得virtual DOM, 然后根据比较新的virtual DOM 和旧的virtual DOM 之间的差异, 计算出从旧的virtual DOM 到新的virtual DOM 所需要的DOM 操作步骤;

生成将一棵树转换成另一棵树的最小操作数。 然而，即使在最前沿的算法中，该算法的复杂程度为 O(n^3)，其中 n 是树中元素的数量

但是这里存在一个问题:
如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂

# 2. diff 算法
## 2.1 diff 算法设计思路
1. 两个不同类型的元素会产生出不同的树
2. 开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定
PS: 在实践中，我们发现以上假设在几乎所有实用的场景下都成立。

React 基于上述两条思路设计了React 的diff 算法, 将事件复杂度从O(n^3) 降到了O(n)

## 2.2 diff 算法的操作思路
1. 当根节点为不同类型时, React 会拆卸原有的树(原先根节点)并且建立起新的树(新的根节点)
2. 当根节点为同一类型是, React 会保留根节点, 仅对其更新变更过的属性
3. 当一个组件更新时, 组件的实例保持不变, 这样state 在跨越不同的渲染层时保持一致, React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法, 然后调用render 方法(这种情况是组件强制刷新的情况, 可以通过调用this.forceUpdate() 函数来强制重绘组件)
4. 对节点进行递归: 无keys; 在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation; 
5. 对节点进行递归: 有keys; 当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素; 给一个元素加上key 之后, React 能够快速判断出一个元素是否是新元素, 并且计算出元素的移动规则

# 3. 注意点
1. 你也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，但一旦有顺序修改，diff 就会变得慢
2. 当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改导致无法预期的变动
3. Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失(key 可以使用hash 值)

